"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressesUtxosAssetAll = exports.addressesUtxosAsset = exports.addressesUtxosAll = exports.addressesUtxos = exports.addressesTransactionsAll = exports.addressesTransactions = exports.addressesExtended = exports.addressesTotal = exports.addresses = void 0;
const utils_1 = require("../../../utils");
const errors_1 = require("../../../utils/errors");
async function addresses(address) {
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1.handleError)(err)));
    });
}
exports.addresses = addresses;
async function addressesTotal(address) {
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/total`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1.handleError)(err)));
    });
}
exports.addressesTotal = addressesTotal;
async function addressesExtended(address) {
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/extended`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1.handleError)(err)));
    });
}
exports.addressesExtended = addressesExtended;
async function addressesTransactions(address, pagination, additionalOptions) {
    const additionalParams = (0, utils_1.getAdditionalParams)(additionalOptions);
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/transactions`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
                from: additionalParams.from,
                to: additionalParams.to,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            if (err && err.response && err.response.statusCode === 404) {
                resolve([]);
            }
            reject((0, errors_1.handleError)(err));
        });
    });
}
exports.addressesTransactions = addressesTransactions;
async function addressesTransactionsAll(address, allMethodOptions, additionalOptions) {
    return (0, utils_1.paginateMethod)((pagination, additionalOptions) => this.addressesTransactions(address, pagination, additionalOptions), allMethodOptions, additionalOptions);
}
exports.addressesTransactionsAll = addressesTransactionsAll;
async function addressesUtxos(address, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/utxos`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1.handleError)(err)));
    });
}
exports.addressesUtxos = addressesUtxos;
async function addressesUtxosAll(address, allMethodOptions) {
    return (0, utils_1.paginateMethod)(pagination => this.addressesUtxos(address, pagination), allMethodOptions);
}
exports.addressesUtxosAll = addressesUtxosAll;
async function addressesUtxosAsset(address, asset, pagination) {
    // TODO: test is missing since we can't guarantee that list of address's utxos won't change in the future
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`addresses/${address}/utxos/${asset}`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => reject((0, errors_1.handleError)(err)));
    });
}
exports.addressesUtxosAsset = addressesUtxosAsset;
async function addressesUtxosAssetAll(address, asset, allMethodOptions) {
    return (0, utils_1.paginateMethod)(pagination => this.addressesUtxosAsset(address, asset, pagination), allMethodOptions);
}
exports.addressesUtxosAssetAll = addressesUtxosAssetAll;
