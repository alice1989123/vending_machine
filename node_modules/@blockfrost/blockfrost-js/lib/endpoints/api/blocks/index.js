"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blocksAddressesAll = exports.blocksAddresses = exports.blocksTxsAll = exports.blocksTxs = exports.blocksPrevious = exports.blocksNext = exports.blocksLatestTxsAll = exports.blocksLatestTxs = exports.blocksLatest = exports.blocks = void 0;
const utils_1 = require("../../../utils");
const errors_1 = require("../../../utils/errors");
async function blocks(hashOrNumber) {
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
exports.blocks = blocks;
async function blocksLatest() {
    return new Promise((resolve, reject) => {
        this.instance(`blocks/latest`)
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
exports.blocksLatest = blocksLatest;
async function blocksLatestTxs(pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/latest/txs`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            return reject((0, errors_1.handleError)(err));
        });
    });
}
exports.blocksLatestTxs = blocksLatestTxs;
async function blocksLatestTxsAll(allMethodOptions) {
    return (0, utils_1.paginateMethod)(pagination => this.blocksLatestTxs(pagination), allMethodOptions);
}
exports.blocksLatestTxsAll = blocksLatestTxsAll;
async function blocksNext(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}/next`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
exports.blocksNext = blocksNext;
async function blocksPrevious(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}/previous`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
exports.blocksPrevious = blocksPrevious;
async function blocksTxs(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}/txs`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                order: paginationOptions.order,
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
exports.blocksTxs = blocksTxs;
async function blocksTxsAll(hashOrNumber, allMethodOptions) {
    return (0, utils_1.paginateMethod)(pagination => this.blocksTxs(hashOrNumber, pagination), allMethodOptions);
}
exports.blocksTxsAll = blocksTxsAll;
async function blocksAddresses(hashOrNumber, pagination) {
    const paginationOptions = (0, utils_1.getPaginationOptions)(pagination);
    return new Promise((resolve, reject) => {
        this.instance(`blocks/${hashOrNumber}/addresses`, {
            searchParams: {
                page: paginationOptions.page,
                count: paginationOptions.count,
                // order: paginationOptions.order, // no ordering on /blocks/{hash}/addresses
            },
        })
            .then(resp => {
            resolve(resp.body);
        })
            .catch(err => {
            reject((0, errors_1.handleError)(err));
        });
    });
}
exports.blocksAddresses = blocksAddresses;
async function blocksAddressesAll(hashOrNumber, allMethodOptions) {
    return (0, utils_1.paginateMethod)(pagination => this.blocksAddresses(hashOrNumber, pagination), allMethodOptions);
}
exports.blocksAddressesAll = blocksAddressesAll;
