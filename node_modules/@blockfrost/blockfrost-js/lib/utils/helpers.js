"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyWebhookSignature = exports.parseAsset = exports.getFingerprint = exports.hexToString = exports.deriveAddress = void 0;
const crypto_1 = require("crypto");
const cardano_serialization_lib_nodejs_1 = require("@emurgo/cardano-serialization-lib-nodejs");
const cip14_js_1 = __importDefault(require("@emurgo/cip14-js"));
const errors_1 = require("./errors");
/**
 * Derives an address with derivation path m/1852'/1815'/account'/role/addressIndex
 * If role === 2 then it returns a stake address (m/1852'/1815'/account'/2/addressIndex)
 *
 * @Returns {address: string, path: number[] } An object with bech32 address and corresponding partial derivation path {address: string, path: [role, addressIndex]}
 * */
const deriveAddress = (accountPublicKey, role, addressIndex, isTestnet, isByron) => {
    const accountKey = cardano_serialization_lib_nodejs_1.Bip32PublicKey.from_bytes(Buffer.from(accountPublicKey, 'hex'));
    const utxoPubKey = accountKey.derive(role).derive(addressIndex);
    const mainStakeKey = accountKey.derive(2).derive(0);
    const testnetNetworkInfo = cardano_serialization_lib_nodejs_1.NetworkInfo.testnet();
    const mainnetNetworkInfo = cardano_serialization_lib_nodejs_1.NetworkInfo.mainnet();
    const networkId = isTestnet
        ? testnetNetworkInfo.network_id()
        : mainnetNetworkInfo.network_id();
    const utxoPubKeyHash = utxoPubKey.to_raw_key().hash();
    const mainStakeKeyHash = mainStakeKey.to_raw_key().hash();
    const utxoStakeCred = cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(utxoPubKeyHash);
    const mainStakeCred = cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(mainStakeKeyHash);
    const baseAddr = cardano_serialization_lib_nodejs_1.BaseAddress.new(networkId, utxoStakeCred, mainStakeCred);
    utxoStakeCred.free();
    mainStakeCred.free();
    mainStakeKeyHash.free();
    utxoPubKeyHash.free();
    const baseAddrBech32 = baseAddr.to_address().to_bech32();
    baseAddr.free();
    if (role === 2 && !isByron) {
        const addressSpecificStakeKey = accountKey.derive(2).derive(addressIndex);
        const stakeKeyHash = addressSpecificStakeKey.to_raw_key().hash();
        const stakeCred = cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(stakeKeyHash);
        // always return stake address
        const rewardAddr = cardano_serialization_lib_nodejs_1.RewardAddress.new(networkId, stakeCred);
        const rewardAddrBech32 = rewardAddr.to_address().to_bech32();
        rewardAddr.free();
        addressSpecificStakeKey.free();
        stakeKeyHash.free();
        stakeCred.free();
        return {
            address: rewardAddrBech32,
            path: [role, addressIndex],
        };
    }
    if (isByron) {
        const protocolMagic = isTestnet
            ? testnetNetworkInfo.protocol_magic()
            : mainnetNetworkInfo.protocol_magic();
        const byronAddress = cardano_serialization_lib_nodejs_1.ByronAddress.icarus_from_key(utxoPubKey, protocolMagic);
        const byronAddrBase58 = byronAddress.to_base58();
        byronAddress.free();
        return {
            address: byronAddrBase58,
            path: [role, addressIndex],
        };
    }
    mainStakeKey.free();
    utxoPubKey.free();
    accountKey.free();
    testnetNetworkInfo.free();
    mainnetNetworkInfo.free();
    return {
        address: baseAddrBech32,
        path: [role, addressIndex],
    };
};
exports.deriveAddress = deriveAddress;
const hexToString = (input) => {
    const hex = input.toString();
    let str = '';
    for (let n = 0; n < hex.length; n += 2) {
        str += String.fromCharCode(parseInt(hex.substr(n, 2), 16));
    }
    return str;
};
exports.hexToString = hexToString;
const getFingerprint = (policyId, assetName) => cip14_js_1.default.fromParts(Uint8Array.from(Buffer.from(policyId, 'hex')), Uint8Array.from(Buffer.from(assetName || '', 'hex'))).fingerprint();
exports.getFingerprint = getFingerprint;
const parseAsset = (hex) => {
    const policyIdSize = 56;
    const policyId = hex.slice(0, policyIdSize);
    const assetNameHex = hex.slice(policyIdSize);
    const assetName = (0, exports.hexToString)(assetNameHex);
    const fingerprint = (0, exports.getFingerprint)(policyId, assetNameHex);
    return {
        policyId,
        assetName,
        assetNameHex,
        fingerprint,
    };
};
exports.parseAsset = parseAsset;
/**
 * Verifies webhook signature
 *
 * @param {string|Buffer} webhookPayload Buffer or stringified payload of the webhook request.
 * @param {string|Buffer} signatureHeader Blockfrost-Signature header.
 * @param {string} secret Auth token for the webhook.
 * @param {number} [timestampToleranceSeconds=600] Time tolerance affecting signature validity. By default signatures older than 600s are considered invalid.
 * @returns {boolean} Whether the signature is valid.
 * */
const verifyWebhookSignature = (webhookPayload, signatureHeader, secret, timestampToleranceSeconds = 600) => {
    let timestamp;
    if (Array.isArray(signatureHeader)) {
        throw new errors_1.SignatureVerificationError('Unexpected: An array was passed as a Blockfrost-Signature header');
    }
    const decodedWebhookPayload = Buffer.isBuffer(webhookPayload)
        ? webhookPayload.toString('utf8')
        : webhookPayload;
    const decodedSignatureHeader = Buffer.isBuffer(signatureHeader)
        ? signatureHeader.toString('utf8')
        : signatureHeader;
    // Parse signature header (example: t=1648550558,v1=162381a59040c97d9b323cdfec02facdfce0968490ec1732f5d938334c1eed4e,v1=...)
    const signatures = [];
    const tokens = decodedSignatureHeader.split(',');
    for (const token of tokens) {
        const [key, value] = token.split('=');
        switch (key) {
            case 't':
                timestamp = Number(value);
                break;
            case 'v1':
                signatures.push(value);
                break;
            default:
                console.warn(`Cannot parse part of the signature header, key "${key}" is not supported by this version of Blockfrost SDK.`);
        }
    }
    if (!timestamp || tokens.length < 2) {
        // timestamp and at least one signature must be present
        throw new errors_1.SignatureVerificationError('Invalid signature header format.', {
            signatureHeader: decodedSignatureHeader,
            webhookPayload: decodedWebhookPayload,
        });
    }
    if (signatures.length === 0) {
        throw new errors_1.SignatureVerificationError('No signatures with supported version scheme.', {
            signatureHeader: decodedSignatureHeader,
            webhookPayload: decodedWebhookPayload,
        });
    }
    let hasValidSignature = false;
    for (const signature of signatures) {
        // Recreate signature by concatenating timestamp with stringified payload,
        // then compute HMAC using sha256 and provided secret (auth token)
        const signaturePayload = `${timestamp}.${decodedWebhookPayload}`;
        const hmac = (0, crypto_1.createHmac)('sha256', secret)
            .update(signaturePayload)
            .digest('hex');
        // computed hmac should match signature parsed from a signature header
        if (hmac === signature) {
            hasValidSignature = true;
        }
    }
    if (!hasValidSignature) {
        throw new errors_1.SignatureVerificationError('No signature matches the expected signature for the payload.', {
            signatureHeader: decodedSignatureHeader,
            webhookPayload: decodedWebhookPayload,
        });
    }
    const currentTimestamp = Math.floor(new Date().getTime() / 1000);
    if (currentTimestamp - timestamp > timestampToleranceSeconds) {
        // Event is older than timestamp_tolerance_seconds
        throw new errors_1.SignatureVerificationError("Signature's timestamp is outside of the time tolerance", {
            signatureHeader: decodedSignatureHeader,
            webhookPayload: decodedWebhookPayload,
        });
    }
    else {
        // Successfully validate the signature only if it is within timestamp_tolerance_seconds tolerance
        return true;
    }
};
exports.verifyWebhookSignature = verifyWebhookSignature;
