"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAsset = exports.getFingerprint = exports.hexToString = exports.deriveAddress = void 0;
const cardano_serialization_lib_nodejs_1 = require("@emurgo/cardano-serialization-lib-nodejs");
const cip14_js_1 = __importDefault(require("@emurgo/cip14-js"));
/**
 * Derives an address with derivation path m/1852'/1815'/account'/role/addressIndex
 * If role === 2 then it returns a stake address (m/1852'/1815'/account'/2/addressIndex)
 *
 * @Returns {address: string, path: number[] } Bech32 address shaped as {address: string, path: [role, addressIndex]}
 * */
const deriveAddress = (accountPublicKey, role, addressIndex, isTestnet) => {
    const accountKey = cardano_serialization_lib_nodejs_1.Bip32PublicKey.from_bytes(Buffer.from(accountPublicKey, 'hex'));
    const utxoPubKey = accountKey.derive(role).derive(addressIndex);
    const mainStakeKey = accountKey.derive(2).derive(0);
    const networkId = isTestnet
        ? cardano_serialization_lib_nodejs_1.NetworkInfo.testnet().network_id()
        : cardano_serialization_lib_nodejs_1.NetworkInfo.mainnet().network_id();
    const baseAddr = cardano_serialization_lib_nodejs_1.BaseAddress.new(networkId, cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(utxoPubKey.to_raw_key().hash()), cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(mainStakeKey.to_raw_key().hash()));
    if (role === 2) {
        const addressSpecificStakeKey = accountKey.derive(2).derive(addressIndex);
        // always return stake address
        const rewardAddr = cardano_serialization_lib_nodejs_1.RewardAddress.new(networkId, cardano_serialization_lib_nodejs_1.StakeCredential.from_keyhash(addressSpecificStakeKey.to_raw_key().hash()))
            .to_address()
            .to_bech32();
        return {
            address: rewardAddr,
            path: [role, addressIndex],
        };
    }
    return {
        address: baseAddr.to_address().to_bech32(),
        path: [role, addressIndex],
    };
};
exports.deriveAddress = deriveAddress;
const hexToString = (input) => {
    const hex = input.toString();
    let str = '';
    for (let n = 0; n < hex.length; n += 2) {
        str += String.fromCharCode(parseInt(hex.substr(n, 2), 16));
    }
    return str;
};
exports.hexToString = hexToString;
const getFingerprint = (policyId, assetName) => cip14_js_1.default.fromParts(Uint8Array.from(Buffer.from(policyId, 'hex')), Uint8Array.from(Buffer.from(assetName || '', 'hex'))).fingerprint();
exports.getFingerprint = getFingerprint;
const parseAsset = (hex) => {
    const policyIdSize = 56;
    const policyId = hex.slice(0, policyIdSize);
    const assetNameInHex = hex.slice(policyIdSize);
    const assetName = (0, exports.hexToString)(assetNameInHex);
    const fingerprint = (0, exports.getFingerprint)(policyId, assetNameInHex);
    return {
        policyId,
        assetName,
        fingerprint,
    };
};
exports.parseAsset = parseAsset;
