"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.paginateMethod = exports.getAllMethodOptions = exports.getPaginationOptions = exports.getAdditionalParams = exports.validateOptions = void 0;
const config_1 = require("../config");
const validateOptions = (options) => {
    var _a, _b, _c, _d, _e;
    if (!options || (!options.customBackend && !options.projectId)) {
        throw Error('Missing customBackend or projectId option');
    }
    if (!options.projectId && !options.customBackend) {
        throw Error('Missing param projectId in options');
    }
    if (options.version && isNaN(options.version)) {
        throw Error('Param version is not a number');
    }
    if (options.requestTimeout && isNaN(options.requestTimeout)) {
        throw Error('Param requestTimeout is not a number');
    }
    const debug = (_a = options.debug) !== null && _a !== void 0 ? _a : process.env.BLOCKFROST_DEBUG === 'true';
    const errorCodesToRetry = [
        'ETIMEDOUT',
        'ECONNRESET',
        'EADDRINUSE',
        'ECONNREFUSED',
        'EPIPE',
        'ENOTFOUND',
        'ENETUNREACH',
        'EAI_AGAIN',
    ];
    return {
        customBackend: options.customBackend,
        projectId: options.projectId,
        isTestnet: (_b = options.isTestnet) !== null && _b !== void 0 ? _b : deriveTestnetOption(options.projectId, options.isTestnet),
        version: options.version || config_1.DEFAULT_API_VERSION,
        debug,
        http2: (_c = options.http2) !== null && _c !== void 0 ? _c : false,
        requestTimeout: (_d = options.requestTimeout) !== null && _d !== void 0 ? _d : 20000,
        // see: https://github.com/sindresorhus/got/blob/main/documentation/7-retry.md#retry
        retrySettings: (_e = options.retrySettings) !== null && _e !== void 0 ? _e : {
            limit: 20,
            methods: ['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE'],
            statusCodes: [408, 413, 429, 500, 502, 503, 504, 521, 522, 524],
            errorCodes: [
                'ETIMEDOUT',
                'ECONNRESET',
                'EADDRINUSE',
                'ECONNREFUSED',
                'EPIPE',
                'ENOTFOUND',
                'ENETUNREACH',
                'EAI_AGAIN',
            ],
            calculateDelay: (retryObject) => {
                if (errorCodesToRetry.includes(retryObject.error.code)) {
                    // network errors are retried only 3 times
                    if (retryObject.attemptCount === 3) {
                        return 0;
                    }
                }
                // check if retry should be enabled, if so set 1s retry delay
                return retryObject.computedValue !== 0 ? 1000 : 0;
            },
            // maxRetryAfter: undefined,
            // backoffLimit: Number.POSITIVE_INFINITY,
            // noise: 100
        },
    };
};
exports.validateOptions = validateOptions;
const deriveTestnetOption = (projectId, isTestnet) => {
    if (!projectId)
        return undefined;
    if (projectId.includes('mainnet')) {
        return false;
    }
    if (projectId.includes('testnet')) {
        return true;
    }
    if (projectId.includes('ipfs')) {
        return false;
    }
    if (!isTestnet) {
        console.log('WARNING: Old token was used without isTestnet parameter switching to mainnet network');
        return false;
    }
    return undefined;
};
const getAdditionalParams = (options) => {
    if (!options) {
        return {
            from: undefined,
            to: undefined,
        };
    }
    return {
        from: options.from || undefined,
        to: options.to || undefined,
    };
};
exports.getAdditionalParams = getAdditionalParams;
const getPaginationOptions = (options) => {
    if (!options) {
        return {
            page: config_1.DEFAULT_PAGINATION_PAGE_COUNT,
            count: config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT,
            order: config_1.DEFAULT_ORDER,
        };
    }
    return {
        page: options.page || config_1.DEFAULT_PAGINATION_PAGE_COUNT,
        count: options.count || config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT,
        order: options.order || config_1.DEFAULT_ORDER,
    };
};
exports.getPaginationOptions = getPaginationOptions;
const getAllMethodOptions = (options) => {
    if (!options) {
        return {
            batchSize: config_1.DEFAULT_BATCH_SIZE,
            order: config_1.DEFAULT_ORDER,
        };
    }
    return {
        batchSize: options.batchSize || config_1.DEFAULT_PAGINATION_PAGE_COUNT,
        order: options.order || config_1.DEFAULT_ORDER,
    };
};
exports.getAllMethodOptions = getAllMethodOptions;
const paginateMethod = async (fn, allMethodOptions, additionalOptions) => {
    const res = [];
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const options = (0, exports.getAllMethodOptions)(allMethodOptions);
    const getSlice = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => fn({
            page: page + i,
            count,
            order: options.order,
        }, {
            from: additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.from,
            to: additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.to,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const pages = await Promise.all(getSlice());
        for (const p of pages) {
            res.push(...p);
            if (p.length < count) {
                return res; // yikes
            }
        }
    }
};
exports.paginateMethod = paginateMethod;
