"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.paginateMethod = exports.getAllMethodOptions = exports.getPaginationOptions = exports.getAdditionalParams = exports.validateOptions = exports.isDebugEnabled = void 0;
const config_1 = require("../config");
const limiter_1 = require("./limiter");
const isDebugEnabled = () => process.env.BLOCKFROST_DEBUG === 'true';
exports.isDebugEnabled = isDebugEnabled;
const validateOptions = (options) => {
    var _a, _b, _c, _d, _e;
    if (!options || (!options.customBackend && !options.projectId)) {
        throw Error('Missing customBackend or projectId option');
    }
    if (!options.projectId && !options.customBackend) {
        throw Error('Missing param projectId in options');
    }
    if (options.version && isNaN(options.version)) {
        throw Error('Param version is not a number');
    }
    if (options.requestTimeout && isNaN(options.requestTimeout)) {
        throw Error('Param requestTimeout is not a number');
    }
    const debug = (_a = options.debug) !== null && _a !== void 0 ? _a : (0, exports.isDebugEnabled)();
    let rateLimiter;
    if (options.rateLimiter === false) {
        rateLimiter = false;
    }
    else if (options.rateLimiter === true ||
        options.rateLimiter === undefined) {
        rateLimiter = limiter_1.RATE_LIMITER_DEFAULT_CONFIG;
    }
    else if (options.rateLimiter) {
        // custom config
        // eslint-disable-next-line prefer-destructuring
        rateLimiter = options.rateLimiter;
    }
    const errorCodesToRetry = [
        'ETIMEDOUT',
        'ECONNRESET',
        'EADDRINUSE',
        'ECONNREFUSED',
        'EPIPE',
        'ENOTFOUND',
        'ENETUNREACH',
        'EAI_AGAIN',
    ];
    return {
        customBackend: options.customBackend,
        projectId: options.projectId,
        network: (_b = options.network) !== null && _b !== void 0 ? _b : deriveNetworkOption(options.projectId),
        rateLimiter,
        version: options.version || config_1.DEFAULT_API_VERSION,
        debug,
        http2: (_c = options.http2) !== null && _c !== void 0 ? _c : false,
        requestTimeout: (_d = options.requestTimeout) !== null && _d !== void 0 ? _d : 20000,
        // see: https://github.com/sindresorhus/got/blob/main/documentation/7-retry.md#retry
        retrySettings: (_e = options.retrySettings) !== null && _e !== void 0 ? _e : {
            limit: 3,
            methods: ['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE'],
            statusCodes: [408, 413, 429, 500, 502, 503, 504, 521, 522, 524],
            errorCodes: [
                'ETIMEDOUT',
                'ECONNRESET',
                'EADDRINUSE',
                'ECONNREFUSED',
                'EPIPE',
                'ENOTFOUND',
                'ENETUNREACH',
                'EAI_AGAIN',
            ],
            calculateDelay: (retryObject) => {
                if (errorCodesToRetry.includes(retryObject.error.code)) {
                    // network errors are retried only 3 times
                    if (retryObject.attemptCount === 3) {
                        return 0;
                    }
                }
                // check if retry should be enabled, if so set 1s retry delay
                return retryObject.computedValue !== 0 ? 1000 : 0;
            },
            // maxRetryAfter: undefined,
            // backoffLimit: Number.POSITIVE_INFINITY,
            // noise: 100
        },
    };
};
exports.validateOptions = validateOptions;
const deriveNetworkOption = (projectId) => {
    if (!projectId)
        return undefined;
    if (projectId.startsWith('mainnet')) {
        return 'mainnet';
    }
    else if (projectId.startsWith('testnet')) {
        return 'testnet';
    }
    else if (projectId.startsWith('preview')) {
        return 'preview';
    }
    else if (projectId.startsWith('preprod')) {
        return 'preprod';
    }
    else if (projectId.startsWith('ipfs')) {
        return 'ipfs';
    }
    else {
        console.warn('WARNING: Old token was used without network parameter. Switching to mainnet network');
        return 'mainnet';
    }
};
const getAdditionalParams = (options) => {
    if (!options) {
        return {
            from: undefined,
            to: undefined,
        };
    }
    return {
        from: options.from || undefined,
        to: options.to || undefined,
    };
};
exports.getAdditionalParams = getAdditionalParams;
const getPaginationOptions = (options) => {
    if (!options) {
        return {
            page: config_1.DEFAULT_PAGINATION_PAGE_COUNT,
            count: config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT,
            order: config_1.DEFAULT_ORDER,
        };
    }
    return {
        page: options.page || config_1.DEFAULT_PAGINATION_PAGE_COUNT,
        count: options.count || config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT,
        order: options.order || config_1.DEFAULT_ORDER,
    };
};
exports.getPaginationOptions = getPaginationOptions;
const getAllMethodOptions = (options) => {
    if (!options) {
        return {
            batchSize: config_1.DEFAULT_BATCH_SIZE,
            order: config_1.DEFAULT_ORDER,
        };
    }
    return {
        batchSize: options.batchSize || config_1.DEFAULT_PAGINATION_PAGE_COUNT,
        order: options.order || config_1.DEFAULT_ORDER,
    };
};
exports.getAllMethodOptions = getAllMethodOptions;
const paginateMethod = async (fn, allMethodOptions, additionalOptions) => {
    const res = [];
    let page = 1;
    const count = config_1.DEFAULT_PAGINATION_PAGE_ITEMS_COUNT;
    const options = (0, exports.getAllMethodOptions)(allMethodOptions);
    const getSlice = () => {
        const promises = [...Array(options.batchSize).keys()].map(i => fn({
            page: page + i,
            count,
            order: options.order,
        }, {
            from: additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.from,
            to: additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.to,
        }));
        page += options.batchSize;
        return promises;
    };
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const pages = await Promise.all(getSlice());
        for (const p of pages) {
            res.push(...p);
            if (p.length < count) {
                return res; // yikes
            }
        }
    }
};
exports.paginateMethod = paginateMethod;
